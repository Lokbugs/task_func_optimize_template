# task_func_optimize_template
Шаблон для собственного решения задачи на оптимизацию


## Подготовка к работе

1. Сделайте автономную копию данного репозитория в своей группе github (или fork)
2. Сделайте его приватным если опасаетесь, что кто-то подглядит
3. `go.mod` - замените имя модуля на путь в github к вашему проекту, например `github.com/ivan/my_solution`
4. Переименуйте директорию `my_solution` в `<my name>_solution` например `ivan_solution` - это
   нужно чтобы при сравнении всех ответом можно было легко объединить разные решения без конфликтов
5. Аналогично переименуйте пакет в файлах MySuperFunc.go, MySuperFunc_test.go
7. Выполните `go mod tidy` для обновления потенциально отсутствующих пакетов
8. **New** не подумал сразу - функции тоже надо переименовать в `<my name>SuperFunc` (файлы как хотите) а то 
   решения хоть и нормально объединяются - но бенчмарки на вид одинаковые в отчете

## Задача 

Реализовать функцию MySuperFunc таким образом, чтобы она выполнялась
существенно лучше, чем ее изначальная реализация, аналогичная начальной эталонной
версии [BasicSuperFuncImpl](https://github.com/comdiv/task_func_optimize_base_go/blob/main/basis/basis.go)

## Рабочий цикл

1. Выполнить команду `go test ./... -v` - убедиться, что функция правильно рассчитывает значения
   разрешено отклонение не более (0.1%) от значений эталонной функции (не точность до 3-го знака, 
   а именно отклонение от эталонного значения не более 0.1%)
2. Выполнить команду `go test -bench=. -cpu 1 -benchmem ./...` - посмотреть текущее соотношение
   скорости Вашего решения в сравнении с базовой функцией (изначально разницы быть не должно)
3. Собственно попытаться переписать функцию на более оптимальный вариант


## Целевые показатели

Вы соревнуетесь как между друг с другом, так и с автором задачи.

А автор задачи добился следующего (при минимальном объеме кода):

```
comdiv@comdiv-home:~/code/task_func_optimize_base_go$ go test -bench=. -cpu 1 -benchmem ./...
goos: linux
goarch: amd64
pkg: github.com/comdiv/task_func_optimize_base_go/basis
cpu: AMD Ryzen 5 2600 Six-Core Processor            
BenchmarkBasicSuperFuncImpl                  222           5491030 ns/op               0 B/op          0 allocs/op
BenchmarkMySuperFuncImpl                     7033898       169.5 ns/op                 0 B/op          0 allocs/op
PASS
ok      github.com/comdiv/task_func_optimize_base_go/basis      3.148s
```

Итого прирост эффективности стабильно превышает `x30000` - оптимизированная версия 
стабильно в 30000 раз быстрее исходного! При этом функция использует 0 аллокаций! Как и исходная версия.

По идее не зависимо от абсолютных значений производительности (зависят от Вашего процессора)
нужно добиться именно относительного прироста в 30000.

# Дополнительные условия

1. Запрещен импорт дополнительных пакетов, не входящих в stdlib golang
2. Все решение должно находиться в файле MySuperFunc.go и он не может превышать 3000 символов
3. Файл MySuperFunc_test.go - неизменяемый, вносить в него изменения запрещено
4. Можно добавить дополнительные тесты, но только в другой файл, а не в MySuperFunc_test.go

# Окончание работы

После того как вы достигли максимального для себя результата - передайте автору задачи
доступ к Вашему репозиторию. Ваши показатели производительности будут объединены
с данными других участников. Условия бенчмаркинга для всех будут одинаковы.
