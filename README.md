# task_func_optimize_template
Шаблон для собственного решения задачи на оптимизацию


## Подготовка к работе

1. Сделайте автономную копию данного репозитория в своей группе github (или fork)
2. Сделайте его приватным если опасаетесь, что кто-то подглядит
3. `go.mod` - замените имя модуля на путь в github к вашему проекту, например `github.com/ivan/my_solution`
4. Переименуйте директорию `my_solution` в `<my name>_solution` например `ivan_solution` - это
   нужно чтобы при сравнении всех ответом можно было легко объединить разные решения без конфликтов
5. Аналогично переименуйте пакет в файлах MySuperFunc.go, MySuperFunc_test.go
7. Выполните `go mod tidy` для обновления потенциально отсутствующих пакетов
8. **New** не подумал сразу - функции бенчмарков тоже надо переименовать из `BenchmarkMySuperFuncImpl` в `Benchmark<my name>SuperFuncImpl` 
   иначе они сливаются в отчете
9. **New** если кто уже начинал решать - в связи с изменением в базовом пакете надо выполнить `go get -u github.com/comdiv/task_func_optimize_base_go@main`

## Задача 

Реализовать функцию MySuperFunc таким образом, чтобы она выполнялась
существенно лучше, чем ее изначальная реализация, аналогичная начальной эталонной
версии [BasicSuperFuncImpl](https://github.com/comdiv/task_func_optimize_base_go/blob/main/basis/basis.go)

## Рабочий цикл

1. Выполнить команду `go test ./... -v` - убедиться, что функция правильно рассчитывает значения
   разрешено отклонение не более (0.1%) от значений эталонной функции (не точность до 3-го знака, 
   а именно отклонение от эталонного значения не более 0.1%)
2. Выполнить команду `go test -bench=. -cpu 1 -benchmem ./...` - посмотреть текущее соотношение
   скорости Вашего решения в сравнении с базовой функцией (изначально разницы быть не должно)
3. Собственно попытаться переписать функцию на более оптимальный вариант


## Целевые показатели

Вы соревнуетесь как между друг с другом, так и с автором задачи.

> **Внимание!** в этом разделе обновление после того как обнаружился
> определенный хак, от одного из решавших задание! 
> Бенчмарк был заменен на менее предсказуемый и проверяющий выполнение для разных N

А автор задачи добился следующего (при минимальном объеме кода):

```
goos: linux
goarch: amd64
pkg: github.com/comdiv/-task_func_optimize_solution/comdiv_solution
cpu: AMD Ryzen 5 2600 Six-Core Processor            
BenchmarkBasicSuperFuncImpl         1117           1061137 ns/op               0 B/op          0 allocs/op
BenchmarkComdivSuperFuncImpl     6291309               190.6 ns/op             0 B/op          0 allocs/op
PASS
ok      github.com/comdiv/-task_func_optimize_solution/comdiv_solution  2.705s
```

Итого прирост эффективности стабильно превышает ~~`x30000`~~ `x5500` - оптимизированная версия 
стабильно в 5500 раз быстрее для разных N! (30000 прироста это на худшем кейсе при N = 30)
При этом функция использует 0 аллокаций! Как и исходная версия.

По идее не зависимо от абсолютных значений производительности (зависят от Вашего процессора)
нужно добиться именно относительного прироста в `x5500` на рандомизированном бенчмарке.

Все решения при сравнении будут находится в равных условиях (использовать один и тот же набор кейсов)

# Дополнительные условия

1. Запрещен импорт дополнительных пакетов, не входящих в stdlib golang
2. Все решение должно находиться в файле MySuperFunc.go и он не может превышать 3000 символов
3. Файл MySuperFunc_test.go - неизменяемый, вносить в него изменения запрещено
4. Можно добавить дополнительные тесты, но только в другой файл, а не в MySuperFunc_test.go

# Окончание работы

После того как вы достигли максимального для себя результата - передайте автору задачи
доступ к Вашему репозиторию. Ваши показатели производительности будут объединены
с данными других участников. Условия бенчмаркинга для всех будут одинаковы.
